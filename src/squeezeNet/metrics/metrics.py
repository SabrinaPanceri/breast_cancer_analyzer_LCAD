'''
This program reads a result file generated by SqueezeNet for breast cancer detection and calculates the performance metrics.
Input: 
    - one text file containing the results generated by SqueezeNet for breast cancer detection (one image per line).
Output: 
    - the optimal classification thresholds.
    - the performance metrics for each threshold.
'''

import sys
import argparse
import numpy as np

''' Global definitions '''
valid_cancer_classes = {0: 'benign', 1: 'malignant'}


def is_int(x):
    try:
        int(x)
        return True
    except ValueError:
        return False


def is_float(x):
    try:
        float(x)
        return True
    except ValueError:
        return False


def calculate_metrics(optimal_thresholds, input_data, threshold_1, threshold_2):
    
    
    return


def read_input_file(infile):
    ''' Expected line format: <image_fullpath>,<ground_truth_class>,<class_prob[0]>,<class_prob[1]>,... '''
    input_data = []
    linenum = 0
    errors = 0
    for (linenum, line) in enumerate(infile, start=1):
        fields = line.split(',')
        if len(fields) < 4:
            print('{}Error in line #{}: too few comma-separated fields: {}'.format(line, linenum, len(fields)))
            errors += 1
            continue
        image_fullpath = fields[0]
        image_fullpath_parts = image_fullpath.split('_')
        if len(image_fullpath_parts) < 2 or image_fullpath_parts[-2] != 'Crop' or image_fullpath[-4:] != '.png':
            print('{}Error in line #{}: image filename is not in format *_Crop_*.png: {}'.format(line, linenum, image_fullpath))
            errors += 1
            continue
        ground_truth_class = int(fields[1]) if is_int(fields[1]) else fields[1]
        if valid_cancer_classes.get(ground_truth_class) == None:
            print('{}Error in line #{}: invalid cancer class: {}\nValid classes are: {}'.format(line, linenum, ground_truth_class, valid_cancer_classes))
            errors += 1
            continue
        class_probs = [ float(prob) if is_float(prob) else prob for prob in fields[2:] ]
        if len(class_probs) > len(valid_cancer_classes) :
            print('{}Error in line #{}: too many class probabilities: {}\nValid classes are: {}'.format(line, linenum, class_probs, valid_cancer_classes))
            errors += 1
            continue
        class_probs_invalid_format = sum( 0 if is_float(prob) else 1 for prob in class_probs )
        if class_probs_invalid_format > 0:
            print('{}Error in line #{}: class probabilities must be float numbers (decimal point is dot)'.format(line, linenum))
            errors += 1
            continue
        total_prob = round(sum(class_probs), 6)
        if total_prob != 1.0:
            print('{}Error in line #{}: total probability is not equal to 1.0: {:.6f}\nList of class probabilities: {}'.format(
                line, linenum, total_prob, class_probs))
            errors += 1
            continue
        input_data.append((linenum, image_fullpath, ground_truth_class, class_probs))
    print('\nRecords read: {}\nErrors: {}\nValid records: {}'.format(linenum, errors, len(input_data)))
    return input_data
    
    
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='This program reads a result file generated by SqueezeNet for breast cancer detection '
                                     'and calculates the performance metrics.', formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('infile', help='file generated by SqueezeNet', nargs='?', type=argparse.FileType('r'))
    parser.add_argument('-o', '--outfile', help='performance metrics', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
    parser.add_argument('-s', '--step', help='step increment of threshold', type=float, default=0.01)
    args = parser.parse_args()

    if args.step <= 0.0 or args.step > 1.0:
        args.step = parser.get_default('step')
        print('Threshold --step argument must be greater than 0.0 and less than 1.0 (now set to default value: {})'.format(args.step))

    squeezenet_data = read_input_file(args.infile)
    
    (optimal_value, threshold_1, threshold_2) = (0.0, 0.0, 0.0)
    optimal_thresholds = []
    for metric in ('Precision', 'Recall', 'Accuracy', 'Specificity', 'Sensitivity', 'F-measure'):
        optimal_thresholds.append([metric, optimal_value, threshold_1, threshold_2])
        
    while threshold_1 <= 1.0:
        threshold_2 = 0.0
        while threshold_2 <= 1.0:
            calculate_metrics(optimal_thresholds, squeezenet_data, threshold_1, threshold_2)
            threshold_2 += args.step
        threshold_1 += args.step
    
    print('\nOptimal thresholds:')
    for optimal in optimal_thresholds:
        print('{:11} : {:.6f}   thresold_1: {:.6f}   threshold_2: {:.6f}'.format(*optimal))
        
    if not args.outfile in (sys.stdout, sys.stderr):
        print('\nPlease find the confusion matrixes in file: {}'.format(args.outfile.name))
        args.outfile.close()
    print
    